name: Build and publish Installer

on:
  workflow_call:
    outputs:
      released:
        description: Was the installer published
        value: "true"
    inputs:
      application_name:
        type: string
        description: Name of the application
      sign_build:
        type: string
        default: "true"
        description: Should the installer be signed
      working_directory:
        type: string
        default: "."
        description: Working directory to run the cargo command

permissions:
  id-token: write
  contents: read

jobs:
  gather_facts:
    runs-on: ubuntu-latest
    outputs:
      WORKING_DIRECTORY: ${{ steps.working_directory.outputs.working_directory }}
      CHANNEL: ${{ steps.channel.outputs.release_channel }}
      LAUNCHER_APP_NAME: ${{ steps.channel.outputs.release_app_name }}
      APP_VERSION: ${{ steps.read_app_version.outputs.value }}
      APP_NAME: ${{ steps.path_name.outputs.app_name }}
      APP_BLOB_NAME: ${{ steps.path_name.outputs.application_blob_name }}
      LAUNCHER_VERSION: ${{ steps.read_launcher_version.outputs.value }}
      LAUNCHER_NAME: ${{ steps.path_name.outputs.launcher_name }}
      LAUNCHER_BLOB_NAME: ${{ steps.path_name.outputs.launcher_blob_name }}
      INSTALLER_NAME: ${{ steps.path_name.outputs.installer_name }}
      INSTALLER_SIGNED_NAME: ${{ steps.path_name.outputs.installer_signed_name }}
      INSTALLER_BLOB_NAME: ${{ steps.path_name.outputs.installer_blob_name }}
      INSTALLER_BLOB_DIR: ${{ steps.path_name.outputs.installer_blob_dir }}
      FALLBACK_BINARY: ${{ steps.path_name.outputs.fallback_binary }}
      PATH_NAME: ${{ steps.path_name.outputs.path_name }}
      EXPIRY: ${{ steps.path_name.outputs.expiry }}
      UPGRADE_CODE: ${{ steps.upgrade_code.outputs.value }}
      GUID_PREFIX: ${{ steps.guid_prefix.outputs.value }}
      PACKAGE: ${{ steps.read_app_name.outputs.value }}
      RELEASE_CHANNEL: ${{ steps.channel.outputs.release_channel }}
      SUBAPPS: ${{ steps.extract_subapps.outputs.subapps }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - uses: SebRollen/toml-action@v1.0.2
        name: Read App name
        id: read_app_name
        with:
          file: "${{ inputs.working_directory }}/Cargo.toml"
          field: "package.name"
      - uses: SebRollen/toml-action@v1.0.2
        name: Read App Version
        id: read_app_version
        with:
          file: "${{ inputs.working_directory }}/Cargo.toml"
          field: "package.version"
      - uses: SebRollen/toml-action@v1.0.2
        name: Read Launcher Version
        id: read_launcher_version
        with:
          file: "${{ inputs.working_directory }}/launcher/Cargo.toml"
          field: "package.version"
      - name: Sanitize woring Directory
        id: working_directory
        shell: bash
        run: |
          input_wd="${{ inputs.working_directory }}"
          if [ "$input_wd" = "." ]; then
            output_wd=""
          elif [[ "$input_wd" != *"/" ]]; then
            output_wd="${input_wd}/"
          else
            output_wd="$input_wd"
          fi
          echo "working_directory=${output_wd}" >> $GITHUB_OUTPUT
      - name: Derive Release Channel
        id: channel
        shell: bash
        run: |
          PACKAGE=${{ steps.read_app_name.outputs.value }}
          VERSION=${{ steps.read_app_version.outputs.value }}
          RELEASE_APP_NAME="${{ inputs.application_name }} Nightly"
          if [[ $GITHUB_REF == refs/heads/nightly-installer ]] ; then
            RELEASE_CHANNEL=nightly
            RELEASE_APP_NAME="${{ inputs.application_name }} Nightly"
          elif [[ $GITHUB_REF == "refs/tags/$PACKAGE-alpha-$VERSION" ]] ; then
            RELEASE_CHANNEL=alpha
            RELEASE_APP_NAME="${{ inputs.application_name }} Alpha"
          elif [[ $GITHUB_REF == "refs/tags/$PACKAGE-beta-$VERSION" ]] ; then
            RELEASE_CHANNEL=beta
            RELEASE_APP_NAME="${{ inputs.application_name }} Beta"
          elif [[ $GITHUB_REF == "refs/tags/$PACKAGE-prod-$VERSION" ]] ; then
            RELEASE_CHANNEL=prod
            RELEASE_APP_NAME="${{ inputs.application_name }}"
          else
            echo "No matching release channel found for $GITHUB_REF, check that the version in Cargo.toml matches the tag."
            exit 1
          fi
          echo release_channel=${RELEASE_CHANNEL} >> $GITHUB_OUTPUT
          echo release_app_name=${RELEASE_APP_NAME} >> $GITHUB_OUTPUT
      - name: Derive path name
        id: path_name
        shell: bash
        env:
          DEFAULT_TOOLCHAIN: stable
          TARGET: x86_64-pc-windows-msvc
        run: |
          toolchain=$(yq -p toml '.toolchain.channel' < rust-toolchain.toml || echo '$DEFAULT_TOOLCHAIN')
          input_string="${{ steps.channel.outputs.release_app_name }}"
          input_version="${{ steps.read_app_version.outputs.value }}"
          path_name="${input_string// /_}"
          app_version="${input_version//./_}"
          fallback_binary="${path_name}"
          app_name="${{ steps.read_app_name.outputs.value }}-${{ env.TARGET }}-${toolchain}-v${{ steps.read_app_version.outputs.value }}-signed.exe"
          launcher_name="${{ steps.read_app_name.outputs.value }}_launcher-${{ env.TARGET }}-${toolchain}-v${{ steps.read_launcher_version.outputs.value }}-signed.exe"
          installer_name="${path_name}.${{ steps.read_launcher_version.outputs.value }}-${{ steps.read_app_version.outputs.value }}.msi"
          installer_signed_name="${path_name}.${{ steps.read_launcher_version.outputs.value }}-${{ steps.read_app_version.outputs.value }}-signed.msi"
          echo "path_name=$path_name" >> $GITHUB_OUTPUT
          echo "fallback_binary=$fallback_binary" >> $GITHUB_OUTPUT
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "launcher_name=$launcher_name" >> $GITHUB_OUTPUT
          echo "installer_name=$installer_name" >> $GITHUB_OUTPUT
          echo "installer_signed_name=$installer_signed_name" >> $GITHUB_OUTPUT
          echo "application_blob_name=${{ steps.read_app_name.outputs.value }}/${{ steps.channel.outputs.release_channel }}/$app_name" >> $GITHUB_OUTPUT
          echo "launcher_blob_name=${{ steps.read_app_name.outputs.value }}_launcher/${{ steps.channel.outputs.release_channel }}/$launcher_name" >> $GITHUB_OUTPUT
          echo "installer_blob_name=${{ steps.read_app_name.outputs.value }}_installer/${{ steps.channel.outputs.release_channel }}/$installer_name" >> $GITHUB_OUTPUT
          echo "installer_blob_dir=${{ steps.read_app_name.outputs.value }}_installer/${{ steps.channel.outputs.release_channel }}" >> $GITHUB_OUTPUT
          echo "expiry=$(date -u -d "120 minutes" '+%Y-%m-%dT%H:%MZ')" >> $GITHUB_OUTPUT
      - uses: SebRollen/toml-action@v1.0.2
        name: Upgrade Code
        id: upgrade_code
        with:
          file: "${{ inputs.working_directory }}/Cargo.toml"
          field: "package.metadata.fslabs.publish.binary.installer.${{ steps.channel.outputs.release_channel }}.upgrade_code"
      - uses: SebRollen/toml-action@v1.0.2
        name: Guid Prefix
        id: guid_prefix
        with:
          file: "${{ inputs.working_directory }}/Cargo.toml"
          field: "package.metadata.fslabs.publish.binary.installer.${{ steps.channel.outputs.release_channel }}.guid_prefix"
      - name: Executables to download
        id: extract_subapps
        shell: bash
        run: |
          # Get the subapps information
          SUB_APPS_OUTPUT=$(yq ".package.metadata.fslabs.publish.binary.installer.sub_apps" -r ${{ inputs.working_directory }}/Cargo.toml -oj | jq -c .)
          if [ "$SUB_APPS_OUTPUT" == "null" ]; then
            SUB_APPS_OUTPUT="{}"
          fi
          # Function to extract semver
          extract_semver() {
            echo "$1" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+'
          }

          get_latest_blob() {
            local app_name=$1
            local version_prefix="${2/./\\.}.*"

            local blobs=$(az storage blob list --connection-string "${{ secrets.ARTIFACTS_CONNECTION_STRING }}" --container-name ${{ vars.ARTIFACTS_CONTAINER }} --prefix "$app_name/${{ steps.channel.outputs.release_channel }}/$app_name" --query "[].name" -o tsv)

            declare -A blob_versions

            for blob in $blobs; do
              local version=$(extract_semver "$blob")
              if [[ -n $version ]] && [[ "$version" =~ $version_prefix ]] && [[ "$blob" =~ .*signed\.exe ]]; then
                blob_versions[$version]=$blob
              fi
            done
            # Sort versions and get the latest one
            local latest_version=$(printf "%s\n" "${!blob_versions[@]}" | sort -V | tail -n 1)
            echo "${blob_versions[$latest_version]}"
          }

          echo 'subapps<<EOF' >> $GITHUB_OUTPUT
          echo $SUB_APPS_OUTPUT | jq -r 'to_entries[] | "\(.key):\(.value.version)"' | while IFS=: read -r key prefix_version; do
            latest_blob=$(get_latest_blob $key "$prefix_version")
            if [[ -n $latest_blob ]]; then
              echo "az storage blob download --container-name ${{ vars.ARTIFACTS_CONTAINER }} --name $latest_blob --file target/x86_64-pc-windows-msvc/release/$key.exe" >> $GITHUB_OUTPUT
            fi
          done
          echo 'EOF' >> $GITHUB_OUTPUT
  generate_wxs:
    runs-on: ubuntu-latest
    needs:
      - gather_facts
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Replace FALLBACK_BINARY
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{FALLBACK_BINARY}}"
          replace: ${{ needs.gather_facts.outputs.FALLBACK_BINARY }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - name: Replace APP_PATH_NAME
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{APP_PATH_NAME}}"
          replace: ${{ needs.gather_facts.outputs.PATH_NAME }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - name: Replace APP_CRATE_NAME
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{APP_CRATE_NAME}}"
          replace: ${{ needs.gather_facts.outputs.PACKAGE }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - name: Replace APP_NAME
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{APP_NAME}}"
          replace: ${{ needs.gather_facts.outputs.LAUNCHER_APP_NAME }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - name: Replace APP_VERSION
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{APP_VERSION}}"
          replace: ${{ needs.gather_facts.outputs.APP_VERSION }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - name: Replace UPGRADE_CODE
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{UPGRADE_CODE}}"
          replace: ${{ needs.gather_facts.outputs.UPGRADE_CODE }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - name: Replace GUID_PREFIX
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "{{GUID_PREFIX}}"
          replace: ${{ needs.gather_facts.outputs.GUID_PREFIX }}
          include: "${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs"
      - uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.gather_facts.outputs.PATH_NAME }}-installer.wxs
          path: ${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer/installer.wxs
  package_installer:
    runs-on: windows-latest
    needs:
      - gather_facts
      - generate_wxs
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Download WXS
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.gather_facts.outputs.PATH_NAME }}-installer.wxs
          path: ${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}installer
      - name: Download Launcher, Application and SubApps
        shell: bash
        working-directory: ${{ needs.gather_facts.outputs.WORKING_DIRECTORY }}
        env:
          AZURE_STORAGE_CONNECTION_STRING: ${{ secrets.ARTIFACTS_CONNECTION_STRING }}
        run: |
          out=target/x86_64-pc-windows-msvc/release
          mkdir -p $out
          az storage blob download --container-name ${{ vars.ARTIFACTS_CONTAINER }} --name ${{ needs.gather_facts.outputs.LAUNCHER_BLOB_NAME }} --file $out/${{ needs.gather_facts.outputs.PACKAGE }}_launcher.exe
          az storage blob download --container-name ${{ vars.ARTIFACTS_CONTAINER }} --name ${{ needs.gather_facts.outputs.APP_BLOB_NAME }} --file $out/${{ needs.gather_facts.outputs.PACKAGE }}.exe
          ${{ needs.gather_facts.outputs.SUBAPPS }}

      - name: Install Wix Toolset
        working-directory: ${{ inputs.working_directory }}/installer
        shell: bash
        run: |
          unzip wix311-binaries.zip

      - name: Candle
        shell: bash
        working-directory: ${{ inputs.working_directory }}/installer
        run: |
          ./wix311-binaries/candle installer.wxs

      - name: Light
        shell: bash
        working-directory: ${{ inputs.working_directory }}/installer
        run: |
          ./wix311-binaries/light -sice:ICE91 -ext WixUIExtension -cultures:en-us installer.wixobj -out ${{ needs.gather_facts.outputs.INSTALLER_NAME }}

      - name: Move to own folder
        shell: pwsh
        run: |
          $Out = New-Item -Path "${{ runner.temp }}\bin_output\${{ needs.gather_facts.outputs.PACKAGE }}_installer\${{ needs.gather_facts.outputs.CHANNEL }}" -ItemType "directory"
          Copy-Item ${{ inputs.working_directory }}\installer\${{ needs.gather_facts.outputs.INSTALLER_NAME }} $Out\${{ needs.gather_facts.outputs.INSTALLER_NAME }}
          $hash = Get-FileHash "$Out\${{ needs.gather_facts.outputs.INSTALLER_NAME }}" -Algorithm SHA512
          echo $hash.Hash >> "$Out\${{ needs.gather_facts.outputs.INSTALLER_NAME }}-sha512.txt"

      - name: Upload unsigned installer to azure
        uses: LanceMcCarthy/Action-AzureBlobUpload@v2.2.1
        with:
          container_name: ${{ vars.ARTIFACTS_CONTAINER }}
          connection_string: ${{ secrets.ARTIFACTS_CONNECTION_STRING }}
          source_folder: ${{ runner.temp }}/bin_output
          delete_if_exists: true

      - name: Generate SAS Url for binary signing
        shell: bash
        id: sas-url
        run: |
          sas=$(az storage blob generate-sas --connection-string "${{ secrets.ARTIFACTS_CONNECTION_STRING }}" --container-name ${{ vars.ARTIFACTS_CONTAINER }} --name ${{ needs.gather_facts.outputs.INSTALLER_BLOB_NAME }} --permissions r --expiry ${{ needs.gather_facts.outputs.EXPIRY }} --https-only --full-uri --output tsv)
          echo "sas=$sas" >> $GITHUB_OUTPUT

      - name: Retrieve signing secret from Vault
        id: import-signing-secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          method: jwt
          url: ${{ vars.VAULT_ADDR }}
          path: github
          role: whirlpool-installer
          secrets: |
            kv-v2/data/whirlpool/signer PAT_TOKEN | WHIRLPOOL_SIGNER_PAT_TOKEN ;
            kv-v2/data/whirlpool/signer REPOSITORY | WHIRLPOOL_SIGNER_REPOSITORY ;

      - run: npm install adm-zip
      - name: Trigger signer workflow
        uses: ForesightMiningSoftwareCorporation/action-trigger-signer-workflow@main
        id: signer-workflow
        if: inputs.sign_build == 'true'
        with:
          token: ${{ steps.import-signing-secrets.outputs.WHIRLPOOL_SIGNER_PAT_TOKEN }}
          signer_repository: ${{ steps.import-signing-secrets.outputs.WHIRLPOOL_SIGNER_REPOSITORY }}
          sas_url: ${{ steps.sas-url.outputs.sas }}
          artifact_to_sign: ${{ needs.gather_facts.outputs.INSTALLER_SIGNED_NAME }}
          blob_dir: ${{ needs.gather_facts.outputs.INSTALLER_BLOB_DIR }}

      - name: Generate signed artifacts checksum windows
        shell: pwsh
        run: |
          $hash = Get-FileHash "${{ runner.temp }}\signed_artifacts\${{ needs.gather_facts.outputs.INSTALLER_BLOB_DIR }}\${{ needs.gather_facts.outputs.INSTALLER_SIGNED_NAME }}" -Algorithm SHA512
          echo $hash.Hash >> "${{ runner.temp }}\signed_artifacts\${{ needs.gather_facts.outputs.INSTALLER_BLOB_DIR }}\${{ needs.gather_facts.outputs.INSTALLER_SIGNED_NAME }}-sha512.txt"

      - name: Upload signed artifacts to Azure Blob Upload
        uses: LanceMcCarthy/Action-AzureBlobUpload@v2.2.1
        with:
          container_name: ${{ vars.ARTIFACTS_CONTAINER }}
          connection_string: ${{ secrets.ARTIFACTS_CONNECTION_STRING }}
          source_folder: ${{ runner.temp }}/signed_artifacts
          delete_if_exists: true

      - name: Upload signed bin to github artifacts
        if: inputs.sign_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-installer-signed
          path: ${{ runner.temp }}/signed_artifacts
          overwrite: true
